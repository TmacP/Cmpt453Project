require "main.Print"

local debug = false
local debug_connect = false
local debug_apple = false
local debug_movement = false
local debug_update = false

local socket = require("socket")

local function put_food(self)
	-- Record the time when the message is sent
	local send_time = socket.gettime()
	local time = os.time()
	local message = "apple " .. time
	self.udp:send(message)
	Print(debug_apple, "Message sent to server:", message)

	-- Receive the new food position from the server
	local response, err = self.udp:receive()
	if response then
		-- Record the time when the response is received
		local receive_time = socket.gettime()

		-- Calculate RTT
		local rtt = receive_time - send_time
		Print(true, string.format("RTT: %.3f seconds", rtt))

		Print(debug_apple, "Received from server:", response)

		-- Parse the response and extract the new food coordinates
		local x, y, server_time = response:match("x=(%d+),y=(%d+),server_time=(%d+%.?%d*)")
		if x and y and server_time then
			self.food = {x = tonumber(x), y = tonumber(y)}
			tilemap.set_tile("#grid", "layer1", self.food.x, self.food.y, 3)

			-- Optional: Sync with server time or log it
			Print(debug_apple, string.format("Server time: %.3f", tonumber(server_time)))
		end
	else
		Print(debug_apple, "Error receiving response:", err)
	end
end

function reset_tilemap(self)
	for x = 2, 47 do
		for y = 2, 47 do
			tilemap.set_tile("#grid", "layer1", x, y, 1)
		end
	end
	if self.food then
		tilemap.set_tile("#grid", "layer1", self.food.x, self.food.y, 3)
	end
end

function init(self)
	self.udp = assert(socket.udp())
	self.udp:setpeername("0.0.0.0", 12345)
	self.udp:settimeout(0.1)

	self.udp:send("Connect")
	local response, err = self.udp:receive()
	if response then
		local x, y = response:match("x=(%d+),y=(%d+)")
		self.food = {x = tonumber(x), y = tonumber(y)}
	else
		Print(debug_connect, "Error receiving response:", err)
	end
	self.segments = {{x = 7, y = 24}, {x = 8, y = 24}, {x = 9, y = 24}, {x = 10, y = 24}}
	self.dir = {x = 1, y = 0}
	self.speed = 7.0
	self.alive = true
	self.t = 0
	math.randomseed(socket.gettime())
end

function update(self, dt)
	if not self.alive then
		-- Reset the tilemap to remove old snake body and food
		reset_tilemap(self)

		-- Reset snake to the initial size and position when alive is false
		self.segments = {
			{x = 7, y = 24},
			{x = 8, y = 24},
			{x = 9, y = 24},
			{x = 10, y = 24}
		}
		self.dir = {x = 1, y = 0}  -- Set the starting direction
		self.speed = 7.0  -- Reset speed (optional)
		self.alive = true  -- Set alive back to true to resume playing
		self.t = 0  -- Reset timer

		return  -- Skip the rest of the update loop and return to start fresh
	end

	self.t = self.t + dt
	if self.t >= 1.0 / self.speed then
		-- Calculate the direction to the apple
		local head = self.segments[#self.segments]
		local second_to_last = self.segments[#self.segments - 1]  -- Get the segment behind the head

		local dx = self.food.x - head.x
		local dy = self.food.y - head.y

		-- Determine the direction with priority for horizontal movement
		if math.abs(dx) > 0 then
			local proposed_dir = {x = dx > 0 and 1 or -1, y = 0}
			-- Prevent reversing into the body
			if not (second_to_last and head.x + proposed_dir.x == second_to_last.x and head.y + proposed_dir.y == second_to_last.y) then
				self.dir = proposed_dir
			end
		elseif math.abs(dy) > 0 then
			local proposed_dir = {x = 0, y = dy > 0 and 1 or -1}
			-- Prevent reversing into the body
			if not (second_to_last and head.x + proposed_dir.x == second_to_last.x and head.y + proposed_dir.y == second_to_last.y) then
				self.dir = proposed_dir
			end
		end

		-- Move the snake
		local newhead = {x = head.x + self.dir.x, y = head.y + self.dir.y}
		table.insert(self.segments, newhead)

		-- Get the tile at the new head position
		local tile = tilemap.get_tile("#grid", "layer1", newhead.x, newhead.y)

		if tile == 2 or tile == 4 then  -- Collision with snake body or wall
			self.alive = false
		elseif tile == 3 then  -- Collision with apple
			self.speed = self.speed + 0.5  -- Increase speed
			put_food(self)  -- Generate a new apple position
		else
			-- Remove the tail segment
			local tail = table.remove(self.segments, 1)
			tilemap.set_tile("#grid", "layer1", tail.x, tail.y, 1)
		end

		-- Update the grid with the new snake segments
		for i, s in ipairs(self.segments) do
			tilemap.set_tile("#grid", "layer1", s.x, s.y, 2)
		end

		-- Receive data from the server (if applicable)
		local response, err = self.udp:receive()
		if response then
			local x, y = response:match("x=(%d+),y=(%d+)")
			if x and y then
				-- Update the old food position to empty (tile 1)
				if self.food then
					tilemap.set_tile("#grid", "layer1", self.food.x, self.food.y, 1)
				end
				-- Update the new food position
				self.food = {x = tonumber(x), y = tonumber(y)}
				tilemap.set_tile("#grid", "layer1", self.food.x, self.food.y, 3)
			end
		elseif err ~= "timeout" then
			Print(debug_update, "Error receiving response:", err)
		end

		-- Reset timer
		self.t = 0
	end
end
