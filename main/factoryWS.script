local waiting_for_response = false -- Flag to track if a response is pending
local last_sent_timestamp = nil -- Store the last sent timestamp

-- WebSocket callback function
local function websocket_callback(self, conn, data)
	if data.event == websocket.EVENT_DISCONNECTED then
		print("Disconnected: " .. tostring(conn))
		self.connection = nil
	elseif data.event == websocket.EVENT_CONNECTED then
		send_timestamp(conn)  -- Send the first timestamp when connected
	elseif data.event == websocket.EVENT_ERROR then
		print("Error: '" .. tostring(data.message) .. "'")
		if data.handshake_response then
			print("Handshake response status: '" .. tostring(data.handshake_response.status) .. "'")
			for key, value in pairs(data.handshake_response.headers) do
				print("Handshake response header: '" .. key .. ": " .. value .. "'")
			end
			print("Handshake response body: '" .. tostring(data.handshake_response.response) .. "'")
		end
	elseif data.event == websocket.EVENT_MESSAGE then
		pprint(data)
		
		receive_timestamp(data)  -- Process the echoed timestamp
	end
end

function init(self)
	self.url = "ws://0.0.0.0:12345"--"ws://66.51.126.183:12345"
	local params = {}
	self.connection = websocket.connect(self.url, params, websocket_callback)
end


function receive_timestamp(data)
	-- Extract and parse the clients section
	local clients_section = data.message:match("'clients': %[(.+)%]")
	if clients_section then
		for client_entry in clients_section:gmatch("{.-}") do
			local id = client_entry:match("'id': (%d+)")
			local x, y = client_entry:match("'coords': %(([%d%.%-]+), ([%d%.%-]+)%)")
			if id and x and y then
				print(string.format("Client ID: %s, Position: (%s, %s)", id, x, y))
			end
		end
	end
	
	-- When the message is received (echoed timestamp), calculate the round trip time
	local received_time = socket.gettime()  -- Get the current time when the response is received
	--print(received_time)
	local sent_time = tonumber(data.message:match("Timestamp: ([%d%.]+)"))  -- Match the full floating-point number	
	--print(sent_time)
	if sent_time then
		-- Calculate the round-trip time (difference between sent and received times)
		local round_trip_time = (received_time - sent_time) * 1000 -- Convert to milliseconds
		print(string.format("RTT: %.2f ms", round_trip_time))  -- Log the round-trip time with milliseconds precision
		-- After receiving the response, set waiting_for_response to false
		waiting_for_response = false  -- Reset flag to allow sending the next timestamp
	end
end

function finalize(self)
	if self.connection ~= nil then
		websocket.disconnect(self.connection)
	end
end


-- Combined function to send timestamp if no response is pending
function send_timestamp(self)
	if not waiting_for_response then
		-- Only send a timestamp if we're not waiting for a response
		if self.connection then  -- Ensure the connection is valid
			local timestamp = socket.gettime()  -- Get the current Unix timestamp
			local timestamp_message = "Timestamp: " .. tostring(timestamp)
			websocket.send(self.connection, timestamp_message)  -- Send timestamp to the server
			--print("Sent timestamp: " .. timestamp_message)  -- Log the sent timestamp

			last_sent_timestamp = timestamp  -- Record the sent timestamp
			waiting_for_response = true  -- Set flag to wait for the response
		else
			print("Error: Connection is not valid.")
		end
	end
end

-- Update function to repeatedly call send_timestamp
function update(self, dt)
	send_timestamp(self)  -- Call the consolidated function in the update loop
end
