local waiting_for_response = false -- Flag to track if a response is pending
local koi_data = {}  -- Table to store koi instances and their positions


-- WebSocket callback function
local function websocket_callback(self, conn, data)
	if data.event == websocket.EVENT_DISCONNECTED then
		print("Disconnected: " .. tostring(conn))
		self.connection = nil
	elseif data.event == websocket.EVENT_CONNECTED then
		send_timestamp(conn)  -- Send the first timestamp when connected
	elseif data.event == websocket.EVENT_ERROR then
		print("Error: '" .. tostring(data.message) .. "'")
		if data.handshake_response then
			print("Handshake response status: '" .. tostring(data.handshake_response.status) .. "'")
			for key, value in pairs(data.handshake_response.headers) do
				print("Handshake response header: '" .. key .. ": " .. value .. "'")
			end
			print("Handshake response body: '" .. tostring(data.handshake_response.response) .. "'")
		end
	elseif data.event == websocket.EVENT_MESSAGE then
		pprint(data)
		receive_timestamp(data)  -- Process the echoed timestamp
	end
end

function init(self)
	self.url = "ws://0.0.0.0:12345"--"ws://66.51.126.183:12345"
	local params = {}
	self.connection = websocket.connect(self.url, params, websocket_callback)
end


function receive_timestamp(data)
	-- Extract and parse the clients section
	client_id = data.message:match("'your_id': (%d+)")
	label.set_text("#id", "Client id: " .. client_id)
	local clients_section = data.message:match("'clients': %[(.-)%]")

	local active_clients = {} -- Temporary table to store active client IDs

	if clients_section then
		for client_entry in clients_section:gmatch("{.-}") do
			local id = client_entry:match("'id': (%d+)")
			local x, y = client_entry:match("'coords': %(([%d%.%-]+), ([%d%.%-]+)%)")
			local angle = client_entry:match("'angle': (%d+%.?%d*)")
			if id and x and y then
				active_clients[id] = true -- Mark client as active
				koi(id, tonumber(x), tonumber(y), tonumber(angle), client_id)
			end
		end
	end

	-- Find disconnected clients
	for id in pairs(koi_data) do
		if not active_clients[id] then
			-- Remove the koi game object and its data
			if koi_data[id].instance then
				go.delete(koi_data[id].instance) -- Delete the game object
				print(string.format("Removed disconnected Koi ID %s", id))
			end
			koi_data[id] = nil -- Remove from koi_data
		end
	end

	-- Process RTT (round trip time) as before
	local received_time = socket.gettime()
	local sent_time = tonumber(data.message:match("Timestamp: ([%d%.]+)"))
	if sent_time then
		local round_trip_time = (received_time - sent_time) * 1000
		local formatted_rtt = string.format("RTT: %d ms", round_trip_time)
		print(formatted_rtt)  -- Print to console
		label.set_text("#rtt", formatted_rtt)  -- Set the label text
		waiting_for_response = false
	end
end




function koi(id, x, y, angle, client_id)
	-- Check if the koi is the client's
	local is_client_koi = (id == client_id)

	-- Ensure koi_data for the client has a target
	if not koi_data[id] then
		-- Create new koi data for the client with an initial random target
		koi_data[id] = {
			instance = nil, -- This will be set later when creating the koi
			x = x,
			y = y,
			target = { x = math.random(0, 360), y = math.random(0, 640),
			angle = 0 }
		}
		--print(string.format("Initialized new target for Koi ID %s: (%s, %s)", id, koi_data[id].target.x, koi_data[id].target.y))
	end

	if is_client_koi then
		-- Get the target for the current koi
		local target_x, target_y = koi_data[id].target.x, koi_data[id].target.y
		local direction_x = target_x - x
		local direction_y = target_y - y
		local distance = math.sqrt(direction_x^2 + direction_y^2)

		if distance < 1 then
			-- If the koi is close enough to the target, set a new random target
			koi_data[id].target.x = math.random(0, 360)
			koi_data[id].target.y = math.random(0, 640)
			--print(string.format("Reached target. New target set for Koi ID %s: (%s, %s)", id, koi_data[id].target.x, koi_data[id].target.y))
			label.set_text("#target", "Target set to: " .. koi_data[id].target.x .. " " .. koi_data[id].target.y)
		else

			koi_data[id].angle = angle
			--[[-- Calculate the angle to the target
			local angle = math.atan2(direction_y, direction_x)  -- Angle in radians
			print(string.format("Angle to target: %f radians", angle))  -- Print the angle

			-- Adjust the angle by adding 90 degrees (π/2 radians) if the sprite's "forward" direction is along the X-axis
			angle = angle - math.pi / 2  -- Rotate 90 degrees counterclockwise to align with the sprite's "top"

			-- Normalize the angle to the range [0, 2π)
			if angle < 0 then
				angle = angle + 2 * math.pi  -- Wrap the angle to positive if it's negative
			end

			-- set the tables angle for the koi
			koi_data[id].angle = angle
			
			-- Apply rotation to the koi instance
			if angle ~= 0 then
				go.set_rotation(vmath.quat_rotation_z(angle), koi_data[id].instance)
			end --]]

			-- Move 1 unit closer to the target
			local step = 1
			local step_x = (direction_x / distance) * step
			local step_y = (direction_y / distance) * step

			-- Update the koi's position
			x = x + step_x
			y = y + step_y
		end
	end

	if koi_data[id].instance then
		-- Update existing koi position
		koi_data[id].x = x
		koi_data[id].y = y
		go.set_position(vmath.vector3(x, y, 0), koi_data[id].instance)


		--print(string.format("Updated Koi ID %s to position: (%s, %s)", id, x, y))
	else
		-- Create new koi
		local position = vmath.vector3(x, y, 0) -- Assuming z = 0 for 2D position
		local new_koi = factory.create("#koi_factory", position) -- Create new koi using factory
		koi_data[id].instance = new_koi
		koi_data[id].x = x
		koi_data[id].y = y
		--print(string.format("Created new Koi ID %s at position: (%s, %s)", id, x, y))
	end
end


function finalize(self)
	if self.connection ~= nil then
		websocket.disconnect(self.connection)
	end
end


-- Combined function to send timestamp if no response is pending
function send_timestamp(self)
	if not waiting_for_response then
		-- Only send a timestamp if we're not waiting for a response
		if self.connection then  -- Ensure the connection is valid
			local timestamp = socket.gettime()  -- Get the current Unix timestamp

			-- Ensure that client_id is valid and exists in koi_data
			if client_id and koi_data[client_id] then
				local koi_x = koi_data[client_id].x
				local koi_y = koi_data[client_id].y
				local koi_angle = koi_data[client_id].angle

				-- Construct the message with the timestamp, client ID, and koi position
				local timestamp_message = string.format("Timestamp: %.6f, Client ID: %s, Koi Position: (%.2f, %.2f), Koi Angle: %.2f", timestamp, client_id, koi_x, koi_y, koi_angle)

				-- Send the message to the server
				websocket.send(self.connection, timestamp_message)
				print("Sent timestamp: " .. timestamp_message)  -- Log the sent timestamp

				last_sent_timestamp = timestamp  -- Record the sent timestamp
				waiting_for_response = true  -- Set flag to wait for the response
			else
				local timestamp_message = "Timestamp: " .. tostring(timestamp)

				websocket.send(self.connection, timestamp_message)  -- Send timestamp to the server
				print("Sent timestamp: " .. timestamp_message)  -- Log the sent timestamp
				print("Error: client_id is invalid or koi data not found.")
			end
		else
			print("Error: Connection is not valid.")
		end
	end
end

	
-- Update function to repeatedly call send_timestamp
function update(self, dt)
	send_timestamp(self)  -- Call the consolidated function in the update loop
end
