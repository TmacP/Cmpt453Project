local socket = require("socket")

local host, port = "0.0.0.0", 12345 -- Server address
local tcp = nil
local koi_data = {}  -- Single table to store koi instances and positions
local factory_url = "#koi_factory"  -- Factory URL for spawning koi

-- Called once when the script is initialized
function init(self)
	tcp = assert(socket.tcp())
	tcp:connect(host, port)
	tcp:settimeout(0)
end

-- Receives and processes RTT responses
local function receive_rtt(t)
	local current_time = tostring(socket.gettime())
	local rtt = (current_time - t)  -- Convert to milliseconds
	--print(string.format("RTT: %.2f ms", rtt))
end


local function receive_koi_positions()
	--print("receive_koi_positions()")
	local data = tcp:receive()
	if not data then
		print("No data received")
		return
	end
	--print("data: " .. data)

	for line in data:gmatch("[^\n]+") do
		-- Check if the line is a timestamp
		if line:match("^Received your timestamp:") then
			local timestamp = line:match("^Received your timestamp: (.+)")
			if timestamp then
				receive_rtt(timestamp)
				print("Received timestamp: " .. timestamp)
				-- Handle the timestamp as needed (e.g., store, log, etc.)
			end

			-- Otherwise, assume it's a position
		else
			local id, pos = line:match("([^:]+):([^:]+)")
			if id and pos then
				local x, y = pos:match("([^,]+),([^,]+)")
				if x and y then
					local position = vmath.vector3(tonumber(x), tonumber(y), 0)
					-- Update position in koi_data
					if not koi_data[id] then
						koi_data[id] = { instance = nil, position = position }
					else
						koi_data[id].position = position
					end
				else
					print("Error parsing position: " .. pos)
				end
			else
				print("Unknown data format: " .. line)
			end
		end
	end
end



-- Spawn a koi game object if it doesn't exist
local function spawn_koi(id, position)
	if not koi_data[id].instance then
		local koi = factory.create(factory_url, position)
		koi_data[id].instance = koi
		--print("Spawned koi:", id, "at", position)
	end
end

-- Update an existing koi's position and rotation
local function update_koi_position(id, position)
	local koi_entry = koi_data[id]
	if koi_entry and koi_entry.instance then
		local current_position = go.get_position(koi_entry.instance)
		go.set_position(position, koi_entry.instance)

		-- Calculate rotation to face movement direction
		local dx, dy = position.x - current_position.x, position.y - current_position.y
		if dx ~= 0 or dy ~= 0 then
			local angle = math.atan2(dy, dx) - math.pi / 2  -- Adjust rotation
			go.set_rotation(vmath.quat_rotation_z(angle), koi_entry.instance)
		end
	end
end

-- Manage koi instances (spawn or update positions)
local function update_koi_instances()
	for id, data in pairs(koi_data) do
		if not data.instance then
			spawn_koi(id, data.position)
		else
			update_koi_position(id, data.position)
		end
	end
end

-- Sends a timestamp to the server
local function send_test()
	local timestamp = tostring(socket.gettime())  -- Use precise time in seconds
	tcp:send(timestamp .. "\n")  -- Send the timestamp followed by a newline
	print("Sent timestamp:", timestamp)
end



-- Called every frame
function update(self, dt)
	-- Receive server updates and sync koi positions
	receive_koi_positions()
	update_koi_instances()
	-- send a test to get rtt
	send_test()
end
