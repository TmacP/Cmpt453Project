local waiting_for_response = false -- Flag to track if a response is pending
local last_sent_timestamp = nil -- Store the last sent timestamp

local koi_data = {}  -- Table to store koi instances and their positions
local client_id = nil

-- WebSocket callback function
local function websocket_callback(self, conn, data)
	if data.event == websocket.EVENT_DISCONNECTED then
		print("Disconnected: " .. tostring(conn))
		self.connection = nil
	elseif data.event == websocket.EVENT_CONNECTED then
		send_timestamp(conn)  -- Send the first timestamp when connected
	elseif data.event == websocket.EVENT_ERROR then
		print("Error: '" .. tostring(data.message) .. "'")
		if data.handshake_response then
			print("Handshake response status: '" .. tostring(data.handshake_response.status) .. "'")
			for key, value in pairs(data.handshake_response.headers) do
				print("Handshake response header: '" .. key .. ": " .. value .. "'")
			end
			print("Handshake response body: '" .. tostring(data.handshake_response.response) .. "'")
		end
	elseif data.event == websocket.EVENT_MESSAGE then
		pprint(data)
		receive_timestamp(data)  -- Process the echoed timestamp
	end
end

function init(self)
	self.url = "ws://0.0.0.0:12345"--"ws://66.51.126.183:12345"
	local params = {}
	self.connection = websocket.connect(self.url, params, websocket_callback)
end


function receive_timestamp(data)
	-- Extract and parse the clients section
	client_id = data.message:match("'your_id': (%d+)")
	--print(client_id)
	
	local clients_section = data.message:match("'clients': %[(.+)%]")
	if clients_section then
		for client_entry in clients_section:gmatch("{.-}") do
			local id = client_entry:match("'id': (%d+)")
			local x, y = client_entry:match("'coords': %(([%d%.%-]+), ([%d%.%-]+)%)")
			if id and x and y then
				--print(string.format("Client ID: %s, Position: (%s, %s)", id, x, y))
				koi(id, x, y, client_id)
			end
		end
	end
	
	-- When the message is received (echoed timestamp), calculate the round trip time
	local received_time = socket.gettime()  -- Get the current time when the response is received
	--print(received_time)
	local sent_time = tonumber(data.message:match("Timestamp: ([%d%.]+)"))  -- Match the full floating-point number	
	--print(sent_time)
	if sent_time then
		-- Calculate the round-trip time (difference between sent and received times)
		local round_trip_time = (received_time - sent_time) * 1000 -- Convert to milliseconds
		print(string.format("RTT: %.2f ms", round_trip_time))  -- Log the round-trip time with milliseconds precision
		-- After receiving the response, set waiting_for_response to false
		waiting_for_response = false  -- Reset flag to allow sending the next timestamp
	end

end



function koi(id, x, y, client_id)
	-- Check if the koi already exists
	local is_client_koi = (id == client_id)
	local new_x, new_y = x, y  -- Start with the current coordinates

	if is_client_koi then
		-- Generate small deltas for movement within a random range
		local delta_x = (math.random() - 0.5) * 0.02  -- Random value between -0.01 and 0.01
		local delta_y = (math.random() - 0.5) * 0.02  -- Random value between -0.01 and 0.01

		-- Adjust coordinates with deltas
		new_x = math.max(0, math.min(360, x + delta_x))
		new_y = math.max(0, math.min(640, y + delta_y))

		print(string.format("Adjusted Client Koi ID %s to new position: (%s, %s)", id, new_x, new_y))
	end

	if koi_data[id] then
		-- Update existing koi position
		koi_data[id].x = new_x
		koi_data[id].y = new_y
		go.set_position(vmath.vector3(new_x, new_y, 0), koi_data[id].instance)

		print(string.format("Updated Koi ID %s to position: (%s, %s)", id, new_x, new_y))
	else
		-- Create new koi
		local position = vmath.vector3(new_x, new_y, 0)  -- Assuming z = 0 for 2D position
		local new_koi = factory.create("#koi_factory", position)  -- Create new koi using factory
		koi_data[id] = { instance = new_koi, x = new_x, y = new_y }
		pprint(koi_data)

		print(string.format("Created new Koi ID %s at position: (%s, %s)", id, new_x, new_y))
	end
end

function finalize(self)
	if self.connection ~= nil then
		websocket.disconnect(self.connection)
	end
end


-- Combined function to send timestamp if no response is pending
function send_timestamp(self)
	if not waiting_for_response then
		-- Only send a timestamp if we're not waiting for a response
		if self.connection then  -- Ensure the connection is valid
			local timestamp = socket.gettime()  -- Get the current Unix timestamp

			-- Ensure that client_id is valid and exists in koi_data
			if client_id and koi_data[client_id] then
				local koi_x = koi_data[client_id].x
				local koi_y = koi_data[client_id].y

				-- Construct the message with the timestamp, client ID, and koi position
				local timestamp_message = string.format("Timestamp: %.6f, Client ID: %s, Koi Position: (%.2f, %.2f)", timestamp, client_id, koi_x, koi_y)

				-- Send the message to the server
				websocket.send(self.connection, timestamp_message)
				print("Sent timestamp: " .. timestamp_message)  -- Log the sent timestamp

				last_sent_timestamp = timestamp  -- Record the sent timestamp
				waiting_for_response = true  -- Set flag to wait for the response
			else
				local timestamp_message = "Timestamp: " .. tostring(timestamp)

				websocket.send(self.connection, timestamp_message)  -- Send timestamp to the server
				print("Sent timestamp: " .. timestamp_message)  -- Log the sent timestamp
				print("Error: client_id is invalid or koi data not found.")
			end
		else
			print("Error: Connection is not valid.")
		end
	end
end


-- Update function to repeatedly call send_timestamp
function update(self, dt)
	send_timestamp(self)  -- Call the consolidated function in the update loop
end
