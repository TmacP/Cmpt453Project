local socket = require("socket")

local host, port = "0.0.0.0", 12345 -- Server address
local tcp = nil
local koi_data = {}  -- Single table to store koi instances and positions
local factory_url = "#koi_factory"  -- Factory URL for spawning koi

-- Called once when the script is initialized
function init(self)
	tcp = assert(socket.tcp())
	tcp:connect(host, port)
	tcp:settimeout(0)
end

-- Receive and parse koi positions from the server
local function receive_koi_positions()
--print("receive_koi_positions()")
local data = tcp:receive()
	for line in data:gmatch("[^\n]+") do
		local id, pos = line:match("([^:]+):([^:]+)")
		if id and pos then
			local x, y = pos:match("([^,]+),([^,]+)")
			local position = vmath.vector3(tonumber(x), tonumber(y), 0)
			-- Update position in koi_data
			if not koi_data[id] then
				koi_data[id] = { instance = nil, position = position }
			else
				koi_data[id].position = position
			end
		end
	end
end

-- Spawn a koi game object if it doesn't exist
local function spawn_koi(id, position)
	if not koi_data[id].instance then
		local koi = factory.create(factory_url, position)
		koi_data[id].instance = koi
		print("Spawned koi:", id, "at", position)
	end
end

-- Update an existing koi's position and rotation
local function update_koi_position(id, position)
	local koi_entry = koi_data[id]
	if koi_entry and koi_entry.instance then
		local current_position = go.get_position(koi_entry.instance)
		go.set_position(position, koi_entry.instance)

		-- Calculate rotation to face movement direction
		local dx, dy = position.x - current_position.x, position.y - current_position.y
		if dx ~= 0 or dy ~= 0 then
			local angle = math.atan2(dy, dx) - math.pi / 2  -- Adjust rotation
			go.set_rotation(vmath.quat_rotation_z(angle), koi_entry.instance)
		end
	end
end

-- Manage koi instances (spawn or update positions)
local function update_koi_instances()
	for id, data in pairs(koi_data) do
		if not data.instance then
			spawn_koi(id, data.position)
		else
			update_koi_position(id, data.position)
		end
	end
end

-- this is the timestamp we send to check a round trip
function send_test()
	local data = os.time()
	print(data)
	tcp:send(data)
end

-- Called every frame
function update(self, dt)
	-- Receive server updates and sync koi positions
	receive_koi_positions()
	update_koi_instances()
	-- send a test to get rtt
	--send_test()
end
