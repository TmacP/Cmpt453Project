local socket = require("socket")

local host, port = "0.0.0.0", 12345 -- Server address
local tcp = nil
local koi_data = {}  -- Single table to store koi instances and positions
local local_koi_id = nil  -- Unique ID for the local koi
local factory_url = "#koi_factory"  -- Factory URL for spawning koi

-- Called once when the script is initialized
function init(self)
	tcp = assert(socket.tcp())
	tcp:connect(host, port)
	tcp:settimeout(0)

	-- Generate a unique ID for the local koi
	local_koi_id = "local_koi_" .. tostring(os.time())
	print("Initialized with Local Koi ID:", local_koi_id)
end

-- Send the local koi's position to the server
local function send_koi_position(koi_id, position)
	if tcp then
		local data = string.format("%s:%f,%f\n", koi_id, position.x, position.y)
		tcp:send(data)
	end
end

-- Receive and parse koi positions from the server
local function receive_koi_positions()
	if tcp then
		local data = tcp:receive()
		if data then
			for line in data:gmatch("[^\n]+") do
				local id, pos = line:match("([^:]+):([^:]+)")
				if id and pos then
					local x, y = pos:match("([^,]+),([^,]+)")
					if x and y then
						local position = vmath.vector3(tonumber(x), tonumber(y), 0)

						-- Update position in koi_data
						if not koi_data[id] then
							koi_data[id] = { instance = nil, position = position }
						else
							koi_data[id].position = position
						end
					end
				end
			end
		end
	end
end

-- Spawn a koi game object if it doesn't exist
local function spawn_koi(id, position)
	if not koi_data[id].instance then
		local koi = factory.create(factory_url, position)
		koi_data[id].instance = koi
		print("Spawned koi:", id, "at", position)
	end
end

-- Update an existing koi's position and rotation
local function update_koi_position(id, position)
	local koi_entry = koi_data[id]
	if koi_entry and koi_entry.instance then
		local current_position = go.get_position(koi_entry.instance)
		go.set_position(position, koi_entry.instance)

		-- Calculate rotation to face movement direction
		local dx, dy = position.x - current_position.x, position.y - current_position.y
		if dx ~= 0 or dy ~= 0 then
			local angle = math.atan2(dy, dx) - math.pi / 2  -- Adjust rotation
			go.set_rotation(vmath.quat_rotation_z(angle), koi_entry.instance)
		end
	end
end

-- Manage koi instances (spawn or update positions)
local function update_koi_instances()
	for id, data in pairs(koi_data) do
		if not data.instance then
			spawn_koi(id, data.position)
		else
			update_koi_position(id, data.position)
		end
	end
end

-- Called every frame
function update(self, dt)
	-- Receive server updates and sync koi positions
	receive_koi_positions()
	update_koi_instances()

	-- Send local koi's position to the server
	if koi_data[local_koi_id] and koi_data[local_koi_id].instance then
		send_koi_position(local_koi_id, go.get_position(koi_data[local_koi_id].instance))
	end
end
