local socket = require("socket")

local host, port = "127.0.0.1", 12345
local tcp = nil
local koi_positions = {} -- To store all koi positions
local koi_instances = {} -- To store spawned koi game objects
local local_koi_id = nil -- To store the local koi's ID

-- Fixed tick rate (e.g., 60 ticks per second)
local TICK_RATE = 60.0 / 60.0  -- 60 Hz (game tick every 1/60th of a second)

-- Function to connect to the server
function connect_to_server()
	tcp = assert(socket.tcp())
	tcp:connect(host, port)
	tcp:settimeout(0)
	print("Connected to server")

	-- Assign a unique ID for the local koi when connected
	local_koi_id = "local_koi_" .. tostring(os.time()) -- Example unique ID for local koi
	print("Local Koi ID: " .. local_koi_id)

	-- Optionally spawn the local koi at a random starting position within screen bounds
	local x = math.random(0, 360)  -- Random X position within screen width
	local y = math.random(0, 640)  -- Random Y position within screen height
	send_koi_position(local_koi_id, vmath.vector3(x, y, 0))
end

-- Function to send local koi position to the server
function send_koi_position(koi_id, position)
	if tcp then
		local data = string.format("%s:%f,%f\n", koi_id, position.x, position.y)
		tcp:send(data)
	end
end

-- Function to receive koi positions from the server
function receive_koi_positions()
	if tcp then
		local data, status, partial = tcp:receive()
		if data or partial then
			local response = data or partial
			print("Received koi positions:", response)
			local new_positions = {}

			if response ~= "" then
				-- Parse koi positions
				for line in response:gmatch("[^\n]+") do
					local id, pos = line:match("([^:]+):([^:]+)")
					if id and pos then
						local x, y = pos:match("([^,]+),([^,]+)")
						if x and y then
							new_positions[id] = vmath.vector3(tonumber(x), tonumber(y), 0)
						end
					end
				end

				-- Only update koi positions if they are valid
				if next(new_positions) ~= nil then
					koi_positions = new_positions
				else
					print("No valid koi positions received.")
				end
			else
				print("Empty data received, ignoring.")
			end
		end
	end
end

-- Function to manage koi instances (spawn or update their positions)
function update_koi_instances()
	-- Ensure that koi positions are updated without redundant spawning
	for id, position in pairs(koi_positions) do
		-- Check if koi is not already spawned
		if not koi_instances[id] then
			print("Spawning koi: " .. id)
			koi_instances[id] = spawn_koi(position)
		else
			-- Update the koi's position
			update_koi_position(id, position)
		end
	end
end

-- Function to spawn a new koi object
function spawn_koi(position)
	print("Spawning koi at " .. tostring(position))
	return { position = position }
end

-- Function to update a koi's position
function update_koi_position(id, position)
	if koi_instances[id] then
		koi_instances[id].position = position
		print("Updated position of koi " .. id .. " to " .. tostring(position))
	end
end

-- Function to run the game loop
function game_loop()
	while true do
		-- Receive koi positions from the server
		receive_koi_positions()

		-- Update local koi and other koi instances in the game world
		update_koi_instances()

		-- Send local koi's updated position to the server every tick
		if koi_instances[local_koi_id] then
			send_koi_position(local_koi_id, koi_instances[local_koi_id].position)
		end

		-- Wait for the next game tick
		socket.sleep(TICK_RATE)
	end
end

-- Connect to the server and start the game loop
connect_to_server()
game_loop()
